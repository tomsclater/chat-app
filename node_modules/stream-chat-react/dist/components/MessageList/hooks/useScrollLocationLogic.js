import { useCallback, useEffect, useLayoutEffect, useRef, useState } from 'react';
import { ResizeObserver as Polyfill } from '@juggle/resize-observer';
import { useMessageListScrollManager } from './useMessageListScrollManager';
var isBrowser = typeof window !== 'undefined';
var ResizeObserver = (isBrowser && window.ResizeObserver) || Polyfill;
export var useScrollLocationLogic = function (params) {
    var _a = params.messages, messages = _a === void 0 ? [] : _a, _b = params.scrolledUpThreshold, scrolledUpThreshold = _b === void 0 ? 200 : _b, hasMoreNewer = params.hasMoreNewer, suppressAutoscroll = params.suppressAutoscroll, listElement = params.listElement, ulElement = params.ulElement;
    var _c = useState(false), hasNewMessages = _c[0], setHasNewMessages = _c[1];
    var _d = useState(), wrapperRect = _d[0], setWrapperRect = _d[1];
    var closeToBottom = useRef(false);
    var closeToTop = useRef(false);
    var scrollCounter = useRef({ autoScroll: 0, scroll: 0 });
    var scrollToBottom = useCallback(function () {
        if (!(listElement === null || listElement === void 0 ? void 0 : listElement.scrollTo) || hasMoreNewer || suppressAutoscroll) {
            return;
        }
        scrollCounter.current.autoScroll += 1;
        listElement.scrollTo({
            top: listElement.scrollHeight,
        });
        setHasNewMessages(false);
    }, [listElement, hasMoreNewer, suppressAutoscroll]);
    useEffect(function () {
        if (!listElement)
            return;
        var observer = new ResizeObserver(scrollToBottom);
        var cancelObserverOnUserScroll = function () {
            scrollCounter.current.scroll += 1;
            var userScrolled = scrollCounter.current.autoScroll < scrollCounter.current.scroll;
            if (ulElement && userScrolled) {
                observer.unobserve(ulElement);
                listElement === null || listElement === void 0 ? void 0 : listElement.removeEventListener('scroll', cancelObserverOnUserScroll);
            }
        };
        if (ulElement) {
            observer.observe(ulElement);
        }
        listElement.addEventListener('scroll', cancelObserverOnUserScroll);
        return function () {
            observer.disconnect();
            if (listElement) {
                listElement.removeEventListener('scroll', cancelObserverOnUserScroll);
            }
        };
    }, [ulElement, scrollToBottom]);
    useLayoutEffect(function () {
        if (listElement) {
            setWrapperRect(listElement.getBoundingClientRect());
            scrollToBottom();
        }
    }, [listElement, hasMoreNewer]);
    var updateScrollTop = useMessageListScrollManager({
        messages: messages,
        onScrollBy: function (scrollBy) {
            listElement === null || listElement === void 0 ? void 0 : listElement.scrollBy({ top: scrollBy });
        },
        scrollContainerMeasures: function () { return ({
            offsetHeight: (listElement === null || listElement === void 0 ? void 0 : listElement.offsetHeight) || 0,
            scrollHeight: (listElement === null || listElement === void 0 ? void 0 : listElement.scrollHeight) || 0,
        }); },
        scrolledUpThreshold: scrolledUpThreshold,
        scrollToBottom: scrollToBottom,
        showNewMessages: function () { return setHasNewMessages(true); },
    });
    var onScroll = useCallback(function (event) {
        var element = event.target;
        var scrollTop = element.scrollTop;
        updateScrollTop(scrollTop);
        var offsetHeight = element.offsetHeight;
        var scrollHeight = element.scrollHeight;
        closeToBottom.current = scrollHeight - (scrollTop + offsetHeight) < scrolledUpThreshold;
        closeToTop.current = scrollTop < scrolledUpThreshold;
        if (closeToBottom.current) {
            setHasNewMessages(false);
        }
    }, [updateScrollTop, closeToTop, closeToBottom, scrolledUpThreshold]);
    var onMessageLoadCaptured = useCallback(function () {
        /**
         * A load event (emitted by e.g. an <img>) was captured on a message.
         * In some cases, the loaded asset is larger than the placeholder, which means we have to scroll down.
         */
        if (closeToBottom.current && !closeToTop.current) {
            scrollToBottom();
        }
    }, [closeToTop, closeToBottom, scrollToBottom]);
    return {
        hasNewMessages: hasNewMessages,
        listElement: listElement,
        onMessageLoadCaptured: onMessageLoadCaptured,
        onScroll: onScroll,
        scrollToBottom: scrollToBottom,
        wrapperRect: wrapperRect,
    };
};
